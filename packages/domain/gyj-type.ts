// https://www.typescriptlang.org/play?#code/LAKALgngDgpgBAZSgGwJZgDwBU4wB5gwB2AJgM5xlgBOqRA5gHxwC8cO+hpFABgCQBvOgDMY1OAGEAFgENqAX0EixcAEowq8nnAD8k2eIA+iFOgzqqzAFxwiMAG5jQoSLDgBVKLGoAZGGEJxNiQ0TAByAEEAIQkAEQBRADEAcQAJAEkAKQBpHwBZADkAeQAFAEVVBCx3ADUAdQANAE0ALTDGZxB8KAB7ajA4V3gJGSh0GWRWOH4BT28-ALFFASpaBi1OoY8iVB6iACZ0okCyGABjMF2iDHdmNgAKd1wCYnI4GSIIXTh7gGsbdwASlYzHsPVQJDgNjsjmowM4rwofxsynE6WBLFB4MhenSUNsDjEAG5Ot0+gMZAAjVYyC5wM7IGRkCgIM5SGAAWxkcAEoDg72pNFpAwA+iKhjYAK5EX5EHoAdyIoHkpLwvX6g2g8FZ7K5EjAfWwzy4bx1nO5wTZ5ruBPlPwxzCwqvVAy2R0CRAmR1E1GwNo4L24iCteoNvtRiGYxgjCG+CAA2mExUMwgBdfEwpwgUBkjVuog+v1TAMmlkhmT6vpwYxmrnfd1iT3Ib1iIvQwnUZ3kzVuWsVsN5UZTXkgfnx34wCA2VZ0eipmx9yudkAq7NdNXd-M+xLUHocoqUgBW50wJcRcB6R5PNpHY4nXzocHvPWE7HeFCw48n6YRQcXYe+e8Mw7ec4BbX1P3vVMOhXTYtTAgsxB3PcfFQKgjV-N5pVlBUiHjaDWD5N9MIoeMI1SGAZBIAAaOAADoGIjLAZFQZBUyIvQKKo41z3-Ks9HjcCMC4khGFohi6PA5COVQ9DmNYxh0xsKTdxktDTxY5AYP5Gx8K7DUGSZFkaB4v9yx5Ijky1ABCacaFnZVOhzDcDMZZk4AKSUOVM01zNvOArNgWzbC8yks1XZyXXpNyKHdHyy11bl-MCmBgqIULwv0gZDPcxJkB6GQBhI4NEos0cAvFGzoQy5cIvXKKcooKIeh6SZir7Mr+RS4LKRa5BKKVWC11zClBWoYVoqMuAIjG4VUMCCZ4pK81OoqoZgrAKQ0MTewJklGA0yIqkaTpXbkH2uy1noasQo5MKjDgXrWoGm70uQZBHOGlzsr2Kg4HmsRFrYDAzl+gYzyDGcGFemqbqe-qPhh97GHuM6LvYB1VuofxJWoIhJvcgHxrawM3hmk6wCJxb-P5NH4DYOmiNXOqRoFCmCYocmhQuWSitJhKVuSyqguUxDfU27awnQTk00YPTyuO7mBmljkF3LJdPsi7tQaIP7eamDD+eW0M+hRlWbCwTH-OxsBcfxxr-vUpaufGnmnZpuAVamFWmc1+rN3gvtElQGBkBIQ3SwvK8LlooDiufV8sBtOOjaTYWDo4glYSIi2vwgH8jelEgYGEOgYBITPM2XHT2DzgvI746vAMnHOs6zLWNUV13spixAaElOl2r8yz0+Cj2889-GE8GLaKCZY2ZGD0Pw4lshY8nRTRcLVe6+0uBmaytmlY5jzJXeql+qweCh9KoX1q31sd7CdJCA5WWkcmYwi5LsuK4V2a6Qv05GrRKGshodx+rrAYnlz6Un6gbCGvlQFhhRkA1WGMQRYxxnjE+MDGRwPgMVPBF8YBXzcB7NBUw0G+3AV9KKXcJoOxdsKdwOw9hLQ6nfKqCFtyqV5hgJ+KsyCy3jOlO6Yh2L-3ZkIkB5olzyxZt9ekYNthXAQRw9WYZ8IowkjIjBmIsG2xwQ7VhajirMIuKY9hHshHe1fmQGhij6EAJ7lNCxYAGzUFOBcMxRtOEj3vqovYhxjhiG8ZcPYGAVIoXUgI2eiYhGyz3gwukejG4KMPjrP6njwlqOBoggWJtqDaPuLo+xFsrZERtnbE+OSTy+Mju4upPjrFEX5LYtgQjHGdAdlgHoJAegcP7nSfyEIqHHCIjrLgAxgg0EmXuFA-hy5TGaq1P2WTwb9J6PrNgvN7h9IGYCHpKiDk9GDsgQIUwrFEHuFTZA9wwjClQI4MIgJaJ3IeRMZArz3nS2Jg80GHJFmEBIK8o5a5elbIiF4BAYBCqEL8cMgY-kDQDIoGwU5vMiKlwuSoDFWzzmBCInQKAkoZl91qk5cA8FTnQqgLC+FZD6Y8NbLSmFcLCAwVAL07GCKG5ItWnTKYnkOSTK2mHbG+NdnqX2by8FdUthYF5Uy8ZhYlUwBgFykADtUIynLvrdqAr-JCrYCKoidgCDCrPvg-qty6AThILzeVVKti6odbzFVbAhJuv1epLV3Le4jEIPQPoXxDXUAHsi81MgOTMthU3MgkpKRnHhSG2gGgph7KDTANNEBnVripS4eC2bc2epZb6EtoatUbLgCQQqFpVqeljTYAARCUGAPRFktuokRRNybU19BDmQXSbTVr8n5E2mAraSitXQKgM4qAPhkG7aO-kfaU3BsHRoEd5Vx3jo9nuidMap1wDbdjMgEJiBgGXT23dh611Jo3Tmrdw64D4Vvfe-k8gP2HtTD+r9P6-3KkoIVNCpcM2VuoBAJlnQgA


// come from farrow
type Split<T extends string> = T extends `${infer Char}${infer Rest}` ? Char | Split<Rest> : never

type UpperLetter = Split<'ABCDEFGHIJKLMNOPQRSTUVWXYZ'>

export type Capital = `${UpperLetter}${string}`

type Union2Intersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;

export abstract class Schema {
  abstract __type: unknown
}

export type SchemaCtor<T extends Schema = Schema> = new () => T

export type InternalInfer<T> = T extends SchemaCtor<infer S> | infer S ? S['__type'] : never

export type Infer<T> = T extends SchemaCtor | Schema ? InternalInfer<T> : never

export type SchemaCtorMap = {
  [key: string]: SchemaCtor
}

export type InferFromObject<T extends object> = {
  [key in keyof T as T[key] extends SchemaCtor ? key : never]: Infer<T[key]>
}

type InferFromList<T extends unknown[]> =
  T extends [infer Head, ...infer Tail]
  ? Head extends SchemaCtor ? [Infer<Head>, ...InferFromList<Tail>] : InferFromList<Tail>
  : []

export class Str extends Schema {
  __type!: string
}


export class Num extends Schema {
  __type!: number
}

export class Int extends Schema {
  __type!: number
}

export class Float extends Schema {
  __type!: number
}

export class Bool extends Schema {
  __type!: boolean
}

export abstract class AbstractLiteral extends Schema {
  __type!: this['value']
  abstract value: string | number | boolean | null
}

export const Literal = <const T extends string | number | boolean | null>(value: T) => {
  return class Literal extends AbstractLiteral {
    value = value
  }
}

export abstract class AbstractList extends Schema {
  __type!: Infer<this['item']>[]
  abstract item: SchemaCtor
}

export const List = <T extends SchemaCtor>(item: T) => {
  return class List extends AbstractList {
    item = item
  }
}

export type SchemaField<T extends object, key extends keyof T> = key extends '__type'
  ? never
  : T[key] extends undefined
  ? never
  : T[key] extends SchemaCtor
  ? key
  : never

export abstract class Struct extends Schema {
  __type!: {
    [key in keyof this as SchemaField<this, key>]: Infer<this[key]>
  }
}

export abstract class NullableType extends Schema {
  __type!: Infer<this['Item']> | null | undefined
  abstract Item: SchemaCtor
}

export const Nullable = <T extends SchemaCtor>(Item: T) => {
  return class Nullable extends NullableType {
    Item = Item
  }
}


export abstract class AbstractUnion extends Schema {
  __type!: InferFromList<this['items']>[number]
  abstract items: SchemaCtor[]
}

export const Union = <T extends SchemaCtor[]>(...items: T) => {
  return class Union extends AbstractUnion {
    items = items
  }
}

export abstract class AbstractIntersection extends Schema {
  __type!: Union2Intersection<InferFromList<this['items']>>
  abstract items: SchemaCtor[]
}

export const Intersection = <T extends SchemaCtor[]>(...items: T) => {
  return class Intersection extends AbstractIntersection {
    items = items
  }
}

class Todo extends Struct {
  id = Int
  content = Str
  completed = Bool
}

const TodoList = List(Todo)

const TodoFilter = Union(Literal('active'), Literal('all'), Literal('completed'))

class TodoAppState extends Struct {
  todos = TodoList
  filter = TodoFilter
  input = Str
}


type TodoAppStateType = Infer<TodoAppState>

class Tree extends Struct {
  value = Num
  children = List(Tree)
}

type TreeType = Infer<Tree>

class LinkedList extends Struct {
  value = Num
  next = Nullable(LinkedList)
}


type LinkedListType = Infer<LinkedList>


class Category extends Struct {
  name = Str
  subcategories = List(Category)
}





type CategoryType = Infer<Category>

const data = {
  name: "People",
  subcategories: [
    {
      name: "Politicians",
      subcategories: [
        {
          name: "Presidents",
          subcategories: [],
        },
      ],
    },
  ],
} satisfies CategoryType


